using System;
using System.Collections.Generic;

namespace CodeAnalysis
{
    class Program
    {
        static void Main(string[] args)
        {
        }

        //Поиск ключа "key" в массиве "a" в диапазоне индексов от "low" до "high" путем 
        //разбиения пополам(бинарный поиск с рекурсией)
        static int Func1(KeyValuePair<int, string>[] a, int low, int high, int key)
        {
            int middle = low + ((high - low) / 2);//Определение середины диапазона

            if (low == high)//Условие выхода из рекурсии, когда диапазон сужается 
                //до одного элемента
                return low;//Метод возвращает искомое значение

            if (key > a[middle].Key)//Выполняется, если новый ключ больше среднего 
                //значения (правая часть массива)
                return Func1(a, middle + 1, high, key);//Возвращает результат методa Func1, 
            //которому переданы в качестве аргументов массив "a", следующий после среднего 
            //и последний индексы, а также ключ

            return Func1(a, low, middle, key);//Выполняется, если новый ключ меньше или 
            //равен среднему значению (левая часть массива). Возвращает результат методa 
            //Func1, которому переданы в качестве аргументов массив "a", начальный и средний 
            //индексы, а также ключ
        }

        //Добавление пары ключ(целое число)-значение(строка) "key-value" в массив "a" с 
        //сортировкой по ключу
        static void Func2(ref KeyValuePair<int, string>[] a, int key, string value)
        {
            int pos;//Объявление переменной "pos"(индекс элемента массива, которому будет 
            //присвоена новая пара ключ-значение)  
            KeyValuePair<int, string> keyValuePair;//Объявление новой пары ключ-значение

            if (a.Length == 0)//Выполняется, если изначальный массив не содержит элементов
            {
                Array.Resize(ref a, 1);//Массив увеличивается до одного элемента(пересоздается)
                keyValuePair = new KeyValuePair<int, string>(key, value);//Инициализация новой 
                //пары ключ-значение
                a[0] = keyValuePair;//Присвоение первому и единственному элементу массива 
                //заданной пары ключ-значение
                return;//Выход, метод ничего не возвращает, ключ-значение добавлен в массив
            }

            if (key < a[0].Key)//Выполняется, если новый ключ меньше ключа первого 
                //элемента массива
                pos = 0;//Инициализация переменной "pos" первым индексом массива
            else if (key > a[a.Length - 1].Key)//Выполняется, если новый ключ больше ключа 
                //последнего элемента массива
                pos = a.Length;//Инициализация переменной "pos" индексом массива, 
            //следующим за последним
            else//Выполняется в остальных случаях, т.е. когда новый ключ находится между 
                //первым и последним элементами массива включительно
                pos = Func1(a, 0, a.Length - 1, key);//"pos" инициализируется значением, 
            //возвращаемым методом Func1, которому переданы в качестве аргументов массив "a", 
            //первый индекс и последний индексы, а также ключ
            Array.Resize(ref a, a.Length + 1);//Длина массива увеличивается на 
            //единицу(пересоздается с копированием элементов старого массива)
            for (int i = a.Length - 1; i > pos; i--)//Цикл сдвига всех элементов от вычисленной 
                //ранее позиции "pos" до конца массива, начиная с последнего элемента
                a[i] = a[i - 1];//i-му элементу присваивается значение предыдущего 
            keyValuePair = new KeyValuePair<int, string>(key, value);//Инициализация новой 
            //пары ключ-значение
            a[pos] = keyValuePair;//Присвоение элементу массива с вычисленным индексом "pos" 
            //заданной пары ключ-значение
        }

        /*
        Можно сократить код метода Func1, но сложность алгоритма увеличится 
        с логарифмической до линейной 

        static int Func1(KeyValuePair<int, string>[] a, int key)
            => a.TakeWhile(item => item.Key<key).Count();
        */
    }
}
